import sys
import platform
import binascii
import os
import os.path
import operator
from subprocess import check_output

#******************************************************************************
# Configuration
#******************************************************************************
# Path to bundle file in relative to pycert.py
BUNDLE_FILE = './certificates/featherdefaults.pem'

CFILE_FILENAME = "certificates.h"
CFILE_VARIABLE = "rootca_certs"

CFILE_HEADER = '''\
#ifndef _CERTIFICATES_H_
#define _CERTIFICATES_H_

#ifdef __cplusplus
extern "C"
{
#endif

/* This file is auto-generated by pycert.py. Do not change it manually.
   Certificates are in DER (binary) format */

'''

CFILE_FOOTER = '''
#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* ifndef _CERTIFICATES_H_ */
'''

#******************************************************************************
# Class Implementation
#******************************************************************************
class AdafruitCert(object):
    #def __init__(self):

    def convert(self, filename):
        '''Generating certificates.h from PEM file (only the last certificate)'''
        # We only need the Root CA which is the last certificate in the chain
        (cdata, count) = self.pem2c(self.opencert(filename)[-1])

        # Write C Header file
        self.writeCFlile(cdata, count)

    def create_bundle(self):
        '''Creating RootCA Bundle using ''' + '/certificates/featherdefaults.pem'
        (cdata, count) = "", 0
        for cert in self.opencert(BUNDLE_FILE):
            (cdata, count) = tuple( map(operator.add, (cdata,count), self.pem2c(cert) ) )

        self.writeCFlile(cdata, count)

    def download(self, hostname, port=443):
        '''Download and generate certificate from a hostname'''
        file_pem = hostname + '.crt'

        # Download certificates if not download already
        if not os.path.isfile(file_pem):
            print "Downloading certificates from " + hostname + ' port ' + str(port)
            # Server cert is first, later is RootCA
            # - Windows: it is best to installed cygwin (and have cygwin/bin in PATH)
            # - Linux may need '-CApath /etc/ssl/certs'
            check_output(("echo '' | openssl s_client -connect %s:%d -showcerts | awk '/BEGIN CERT/ {p=1}; p; /END CERT/ {p=0}' > %s") % (hostname, port, file_pem), shell=True)

        self.convert(file_pem)

    def opencert(self, filename):
        # Open PEM file and split cert chain into list
        with open(filename, 'r') as f_pem:
            cert_list =  ["-----BEGIN CERTIFICATE-----" + x for x in  f_pem.read().split("-----BEGIN CERTIFICATE-----")[1:]]
            f_pem.close()
        return cert_list

    def pem2c(self, pemdata):
        # Convert PEM Data to CData and return a tube (cdata, count)
        c_data = ""
        count = 0

        # Write Cert string to temp file
        with open("tmp.pem", "w") as tmppem:
            tmppem.write(pemdata)
            tmppem.close()

        # Convert PEM to DER format
        check_output("openssl x509 -outform der -in tmp.pem -out tmp.der", shell=True)

        # Get Subject, Issur, Enddate for each certificate
        c_data += '/*\n' + check_output("openssl x509 -in tmp.pem -noout -subject -issuer -enddate", shell=True) + '*/\n'

        # Extra data to C Array
        with open("tmp.der", "rb") as tmpder:
            bytes_read = tmpder.read(16)
            while bytes_read != "" :
                c_data += ', '.join("0x{:02X}".format(ord(x)) for x in bytes_read)
                count += len(bytes_read)
                bytes_read = tmpder.read(16)
                c_data += ',\n'
            tmpder.close()

        # Remove temp file
        os.remove("tmp.der")
        os.remove("tmp.pem")

        return (c_data, count)

    def writeCFlile(self, data, count):
        f_out = open(CFILE_FILENAME, 'w')
        f_out.write(CFILE_HEADER)
        #f_out.write(('\n/* This file is generated by following command \n        python %s %s\n*/\n\n') % (sys.argv[0], sys.argv[1]) )
        f_out.write( ("#define ROOTCA_CERTS_LEN        %d\n\n")%(count) )
        f_out.write( ("const uint8_t %s [ROOTCA_CERTS_LEN] = {\n")%(CFILE_VARIABLE) )

        f_out.write(data)

        f_out.write("};\n")
        f_out.write(CFILE_FOOTER)


#******************************************************************************
# Interface
#******************************************************************************
pycert = AdafruitCert()

'''
# Command Line
if (len(sys.argv) < 2):
  print "Download certificate chain from a hostname"
  print ("Usage: python %s <hostname>")%(sys.argv[0])
  sys.exit()

pycert.download(sys.argv[1])
'''

pycert.create_bundle()
#pycert.download("www.google.com")
#pycert.convert("verisign.cer")